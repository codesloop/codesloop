/*
Copyright (c) 2008,2009, David Beck, Tamas Foldi

Redistribution and use in source and binary forms, with or without
modification, are permitted provided that the following conditions
are met:

1. Redistributions of source code must retain the above copyright
   notice, this list of conditions and the following disclaimer.
2. Redistributions in binary form must reproduce the above copyright
   notice, this list of conditions and the following disclaimer in the
   documentation and/or other materials provided with the distribution.

THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
*/

#ifndef _csl_slt3_obj_hh_included_
#define _csl_slt3_obj_hh_included_

/**
  @file obj.hh
  @brief slt3::obj is the base class of the ORM mapped classes
 */

#include "var.hh"
#include "conn.hh"
#include "tran.hh"
#include "sql.hh"
#include "csl_common.hh"
#ifdef __cplusplus

namespace csl
{
  namespace slt3
  {
    /**
    @brief this is the superclass of all ORM user classes

    ORM (object-relational mapping) user's must subclass slt3::obj in order to use
    the ORM facilities. this class provides several helpers for saving, finding, creating and 
    removing ORM objects.
     */
    class obj : public csl::common::obj
    {
      public:

        inline obj() : changed_(false) {} ///<default constructor

        virtual ~obj() {} ///<destructor

        /**
        @brief [abstract] get a connection to the SQLite3 database

        this is an abstract function so subclasses must define this. slt3::reg::helper
        can provide the neccessary functionality
        */
        virtual conn & db() = 0;

        /**
        @brief [abstract] get an instance of sql_helper class

        this is an abtract function so subclasses must define this. other member functions
        use the returned sql::helper to generate SQL query strings.
         */
        virtual sql::helper & sql_helper() const = 0;

        /**
        @brief set the database instance id
        @param id is the identifier value to be set

        this function forwards this call to var_base::helper that will set the right variable's
        content to the given id.
          */
        virtual void set_id(long long id);

        /**
        @brief initialize the database table associated with the given ORM user class
        @param t is the transaction context to be used
        @return true if successful

        the initialization is based on the table name that is stored in the sql::helper and
        the variables that are registered at construction time. the sql::helper generates the
        SQL query (CREATE TABLE...) and this function executes it in the given transaction context.

        this function forwards the call to the var_base::helper
         */
        virtual bool init(tran & t);

        /**
        @brief insert a new record corresponding to the given ORM user class
        @param t is the transaction context to be used
        @return true if successful

        the table name that is stored in the sql::helper and the fields are determined by
        the variables that are registered at construction time. the sql::helper generates the
        SQL query (INSERT INTO...) and this function executes it in the given transaction context.

        this function forwards the call to the var_base::helper. the set_id() function is called
        at the end of this call to set it to the new identifier generated by the database.
         */
        virtual bool create(tran & t);

        /**
        @brief update a record in the database corresponding to the given ORM class instance
        @param t is the transaction context to be used
        @return true if successful

        the table name that is stored in the sql::helper and the fields are determined by
        the variables that are registered at construction time. the sql::helper generates the
        SQL query (UPDATE...) and this function executes it in the given transaction context.

        this function forwards the call to the var_base::helper. the call internally uses the
        parametrized slt3::query interface.
         */
        virtual bool save(tran & t);

        /**
        @brief remove a record from the database corresponding to the given ORM class instance
        @param t is the transaction context to be used
        @return true if successful

        the table name that is stored in the sql::helper and the fields are determined by
        the variables that are registered at construction time. the sql::helper generates the
        SQL query (DELETE...) and this function executes it in the given transaction context.

        this function forwards the call to the var_base::helper. the call internally uses the
        parametrized slt3::query interface.
         */ 
        virtual bool remove(tran & t);

        /**
        @brief find a record in the database corresponding to the given ORM class instance based on the id field
        @param t is the transaction context to be used
        @return true if successful

        the table name that is stored in the sql::helper and the fields are determined by
        the variables that are registered at construction time. the sql::helper generates the
        SQL query (SELECT...) and this function executes it in the given transaction context.

        this function forwards the call to the var_base::helper. the call internally uses the
        parametrized slt3::query interface and sets the internal variables to the returned
        values.
         */ 
        virtual bool find_by_id(tran & t);

        /**
        @brief find a record in the database corresponding to the given ORM class instance based on the given fields
        @param t is the transaction context to be used
        @param field1 to be put into the where conditions
        @param field2 to be put into the where conditions (if not -1)
        @param field3 to be put into the where conditions (if not -1)
        @param field4 to be put into the where conditions (if not -1)
        @param field5 to be put into the where conditions (if not -1)
        @return true if successful

        the table name that is stored in the sql::helper and the fields are determined by
        the variables that are registered at construction time. the sql::helper generates the
        SQL query (SELECT...) and this function executes it in the given transaction context.

        this function forwards the call to the var_base::helper. the call internally uses the
        parametrized slt3::query interface and sets the internal variables to the returned
        values.

        the net result of this call is a SELECT ... SQL call

        the object's database variables will be filled with the returned data. the
        fieldx variables will be used as condition variables. the fields with non-default
        values represent a variable by index. indexing start from zero. the variables
        given are logically AND'ed together.

        to select on the 3rd and 4th variable of the given object one must first set those
        variables to the desired values to be searched for, and then call this function
        with field1=2 and field2=3.
         */
        virtual bool find_by(tran & t,
                             int field1,
                             int field2=-1,
                             int field3=-1,
                             int field4=-1,
                             int field5=-1);

        /**
        @brief initialize the database table associated with the given ORM user class
        @return true if successful

        the initialization is based on the table name that is stored in the sql::helper and
        the variables that are registered at construction time. the sql::helper generates the
        SQL query (CREATE TABLE...) and this function executes it. this function creates a separate
        transaction context.

        this function forwards the call to the var_base::helper
         */
        virtual bool init();

        /**
        @brief insert a new record corresponding to the given ORM user class
        @return true if successful

        the table name that is stored in the sql::helper and the fields are determined by
        the variables that are registered at construction time. the sql::helper generates the
        SQL query (INSERT INTO...) and this function executes it. this function creates a separate
        transaction context.

        this function forwards the call to the var_base::helper. the set_id() function is called
        at the end of this call to set it to the new identifier generated by the database.
         */
        virtual bool create();

        /**
        @brief update a record in the database corresponding to the given ORM class instance
        @return true if successful

        the table name that is stored in the sql::helper and the fields are determined by
        the variables that are registered at construction time. the sql::helper generates the
        SQL query (UPDATE...) and this function executes it. this function creates a separate
        transaction context.

        this function forwards the call to the var_base::helper. the call internally uses the
        parametrized slt3::query interface.
         */
        virtual bool save();

        /**
        @brief remove a record from the database corresponding to the given ORM class instance
        @return true if successful

        the table name that is stored in the sql::helper and the fields are determined by
        the variables that are registered at construction time. the sql::helper generates the
        SQL query (DELETE...) and this function executes it. this function creates a separate
        transaction context.

        this function forwards the call to the var_base::helper. the call internally uses the
        parametrized slt3::query interface.
         */ 
        virtual bool remove();

        /**
        @brief find a record in the database corresponding to the given ORM class instance based on the id field
        @return true if successful

        the table name that is stored in the sql::helper and the fields are determined by
        the variables that are registered at construction time. the sql::helper generates the
        SQL query (SELECT...) and this function executes it. this function creates a separate
        transaction context.

        this function forwards the call to the var_base::helper. the call internally uses the
        parametrized slt3::query interface and sets the internal variables to the returned
        values.
         */ 
        virtual bool find_by_id();

        /**
        @brief find a record in the database corresponding to the given ORM class instance based on the given fields
        @param field1 to be put into the where conditions
        @param field2 to be put into the where conditions (if not -1)
        @param field3 to be put into the where conditions (if not -1)
        @param field4 to be put into the where conditions (if not -1)
        @param field5 to be put into the where conditions (if not -1)
        @return true if successful

        the table name that is stored in the sql::helper and the fields are determined by
        the variables that are registered at construction time. the sql::helper generates the
        SQL query (SELECT...) and this function executes it. this function creates a separate
        transaction context.

        this function forwards the call to the var_base::helper. the call internally uses the
        parametrized slt3::query interface and sets the internal variables to the returned
        values.

        the net result of this call is a SELECT ... SQL call

        the object's database variables will be filled with the returned data. the
        fieldx variables will be used as condition variables. the fields with non-default
        values represent a variable by index. indexing start from zero. the variables
        given are logically AND'ed together.
        
        to select on the 3rd and 4th variable of the given object one must first set those
        variables to the desired values to be searched for, and then call this function
        with field1=2 and field2=3.
         */
        virtual bool find_by(int field1,
                             int field2=-1,
                             int field3=-1,
                             int field4=-1,
                             int field5=-1);

        /**
        @brief polymorphic upcall to signal when an instance is loaded from the database

        this is called when find_by() or find_by_id() calls succeed
         */
        virtual void on_load() {}

        /**
        @brief polymorphic upcall to signal when the state of an instance has changed

        when the ORM variables change then this upcall should be signaled
         */
        virtual void on_change() { changed_ = true; }

        /**
        @brief table name as returned from sql::helper
        @return the table name as char * string
         */
        virtual const char * table_name() const { return sql_helper().table_name(); }

        /**
        @brief return a reference to the internal var_base::helper

        var_helper is used internally to store ORM related variable data
         */
        virtual var_base::helper & var_helper() { return var_helper_; }

        inline void changed(bool c) { changed_ = c; }  ///<signals a changed flag
        inline bool changed() { return changed_; }     ///<checks if the internal variables were changed

      private:
        var_base::helper var_helper_;
        bool changed_;
        inline obj(const obj & other) {}
        inline obj & operator=(const obj & other) { return *this; }

        CSL_OBJ(csl::slt3,obj);
    };
  }
}

#endif /* __cplusplus */
#endif /* _csl_slt3_obj_hh_included_ */
